# -*- coding: utf-8 -*-
"""Homework 2 Албитова

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ogBXs0TxYjndyj4f6qANUjWHFG6344rP

1.	Укажите путь к рабочей папке, где хранятся данные, с помощью функции chdir() из модуля os.
"""

from scipy import stats
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

os.chdir('/content/drive/MyDrive/data ML')

"""2.	Загрузите данные из файла town_1959_2.csv с помощью функции 
read_csv() из модуля pandas. Посмотрите на первые 5 наблюдений с помощью функции head().
Я взяла датасет с калифорнийскими городами, использовала данные за 1980 год. https://www.kaggle.com/datasets/camnugent/california-housing-feature-engineering
"""

ds = pd.read_csv('/content/drive/MyDrive/data ML/cal_populations_city.csv', encoding='cp1251',index_col=0)
ds.head(5)

ds.describe

ds.info()

"""Постройте гистограмму для логарифма численности населения городов, воспользовавшись функцией log10 из модуля numpy для логарифмирования и функцией hist() из модуля matplotlib.pyplot. Сделайте предположение о нормальности прологарифмированных данных"""

plt.hist(np.log10(ds['pop_april_1990']))
plt.show()
#распределение со смещением, отличается от нормального

"""Проведите проверку гипотезы о нормальности распределения прологарифмированных данных на основе критерия Шапиро-Уилка, воспользовавшись функцией shapiro() из модуля scipy.stats. Прокомментируйте результат"""

stats.shapiro(np.log10(ds['pop_april_1990']))

"""Вывод: распределение отличается от нормального, т.к. p-value составляет > 0.05 -  0.0001.

5.	Загрузите данные из файла Albuquerque Home Prices_data.txt с помощью функции read_csv() из модуля pandas. Замените значение -9999, которое здесь употребляется в качестве пустого значения, на корректное пустое значение nan из модуля numpy. Воспользуйтесь при этом функцией replace(). Выведите на экран первые 5 наблюдений преобразованных данных.
Я выгрузила датасет house prices in Perth https://www.kaggle.com/datasets/syuzai/perth-house-prices
"""

hs = pd.read_csv('/content/drive/MyDrive/data ML/all_perth_310121.csv')
hs.head(20)

hs.info()

"""6.	Проверьте очевидный факт, что площадь дома коррелирует с его ценой. Постройте диаграмму рассеяния для переменных цена ('PRICE') и площадь дома ('SQFT'). Воспользуйтесь при этом функцией scatter() из модуля matplotlib.pyplot. Прокомментируйте полученный результат"""

plt.scatter(hs['PRICE'],hs['LAND_AREA'])
plt.show()
#цена и площадь взаимосвязаны, хоть и присутствуют выбросы

"""7.	Проверьте свою гипотезу аналитически с помощью коэффициента корреляции Пирсона. Воспользуйтесь при этом функцией pearsonr() из модуля scipy.stats. Прокомментируйте результат.
Здесь площадь дома измеряется в столбце LAND_AREA
"""

stats.pearsonr(hs['PRICE'],hs['LAND_AREA']) 
#низкая корреляция, т.к. коэф Пирсона = 0.056, pvalue < 0.05

"""8.	Вычислите частную корреляцию между ценой и площадью дома при фиксированных значениях суммы налога. Вам понадобится модуль pingouin, который можно установить с помощью команды !pip install pingouin. Воспользуйтесь функцией partial_corr(data=df, x='PRICE', y='SQFT', covar='TAX') из модуля pingouin. Прокомментируйте полученный результат."""

df=pd.read_csv('/content/drive/MyDrive/data ML/Albuquerque Home Prices_data.txt', sep='\t') 
df=df.replace(-9999,np.nan)
df.head()

!pip install pingouin

import pingouin as pg

pg.partial_corr(data=df, x='PRICE', y='SQFT', covar='TAX')
# p-val < 0.05

pg.partial_corr(data=hs, x='PRICE', y='LAND_AREA', covar='POSTCODE') 
#p value < 0.05, так что есть статичстически достоверная связь между площадью и ценой при фикс значениях суммы нлога

"""9.	Вычислите ранговый коэффициент корреляции Спирмена по данным о цене и площади дома. Воспользуйтесь при этом функцией spearmanr() из модуля scipy.stats. Прокомментируйте результат."""

stats.spearmanr(df['PRICE'],df['SQFT'])
#между данными столбцами (цена и площадь) есть статистическая связь (средняя): при увеличении одной переменной растет и другая, направления их изменения совпадает

stats.spearmanr(hs['PRICE'],hs['LAND_AREA']) 
#между переменными нет сильной связи, т.е. при росте одной из них необязательно растет другая, направление их изменений не совпадает

"""10.	Вычислите ранговый коэффициент корреляции Кендалла по данным о цене и площади дома. Воспользуйтесь при этом функцией kendalltau() из модуля scipy.stats. Прокомментируйте результат."""

stats.kendalltau(df['PRICE'],df['SQFT']) 
#между переменными довольно сильная положительная связь

stats.kendalltau(hs['PRICE'],hs['LAND_AREA']) 
#между переменными нет сильной связи

"""Раздел 3.1. Критерий хи-квадрат для анализа классификации. Отношение к мораторию на смертную казнь

11.	Из 50 опрошенных по поводу отношения к введению моратория на смертную казнь 30 были "за", 20 - "против" (предполагается, что выборка репрезентативна генеральной совокупности). Можно ли утверждать на основании этого опроса, что в совокупности количество сторонников превышает количество противников введения моратория на смертную казнь?
"""

#нет, так как слишком маленькая выборка, нет информации об опрашиваемых (политические предпочтения, например)

"""12.	Вычислите критерий хи-квадрат Пирсона по имеющимся данным о распределении голосов. Сравните его с равномерным распределением. Воспользуйтесь при этом функцией chisquare([30, 20]) из модуля scipy.stats. Прокомментируйте результат.


13.	Предположим, что опрошено не 50, а 100 человек, и соотношение высказавшихся "за" и "против" сохранилось. Тогда эмпирические частоты составили бы 60 "за" и 40 "против", а соответствующие теоретические частоты равнялись бы 50. Изменится ли статистический вывод?

"""

stats.chisquare([30, 20])
#статистически значимые различия в отношении численности сторонников и противников смертной казни не получены, т.е. отклонения статистически не значимы

stats.chisquare([60, 40])
#в днанном случае разница между респондентами уже станет статистически значимым, и она будет означать,

"""14. В качестве ожидаемого (теоретического) распределения может выступать не обязательно равномерное распределение. Например, требуется проверить, что число сторонников введения моратория составляет не менее 80%. Воспользуйтесь функцией chisquare([60, 40], f_exp=[80, 20]) из модуля scipy.stats. Прокомментируйте результат"""

stats.chisquare([60, 40], f_exp=[80, 20]) 
#p-value будет меньше 0.05, так что нулевая гипотеза - " число сторонников введения моратория составляет не менее 80%" - отклоняется

"""15.	Был проведен опрос, в ходе которого для каждого респондента репрезентативной выборки определены пол и один из пяти предпочитаемых политических лидеров. Количество высказавшихся за  каждого из пяти политических лидеров среди мужского пола - [5, 25, 10, 8, 3]. Среди женского пола - [11, 12, 19, 5, 7]. Постройте на основе этих данных таблицу сопряженности, где в строках указан пол, а в столбцах один из пяти лидеров. Проверьте гипотезу о зависимости политических предпочтений от пола респондента с использованием критерия хи-квадрат.
16.	Сначала постройте таблицу сопряжённости, в которой будет указано количество респондентов мужского пола ('male') и женского пола ('female'), высказавшихся за одного из пяти политических лидеров, указанных в столбце таблицы ('leader_1' - 'leader_5'). Воспользуйтесь при этом функцией DataFrame() из модуля pandas. Результат запишите в переменную contingency_table. Выведите ее содержимое  на экран.


17.	На основе таблицы сопряженности проверьте с помощью критерия хи-квадрат гипотезу о равенстве долей респондентов, высказавшихся за и против кандидата. Воспользуйтесь при этом функцией chi2_contingency(contingency_table, correction=False) из модуля scipy.stats. Прокомментируйте результат.

"""

male = [5, 25, 10, 8, 3]
female = [11, 12, 19, 5, 7]
contingency_table=pd.DataFrame([[5, 25, 10, 8, 3],[11, 12, 19, 5, 7]],index=['male','female'],columns=['leader_1','leader_2','leader_3','leader_4','leader_5'])
contingency_table

stats.chi2_contingency(contingency_table, correction=False)
#p-value < 0.05 - есть взаимосвязь между полом респондента и его политическими предпочтениями

"""18.	В регионе ожидаются выборы. Команда кандидата проводит опрос, в результате которого в поддержку кандидата выказалось 28% из 100 опрошенных в городе и 20% из 100 опрошенных на селе. Нужно выяснить, является ли эта разница статистически значимой, и нужно ли разворачивать дополнительную рекламную кампанию на селе. Проверять гипотезу о равенстве распределений будем с использованием критерия хи-квадрат.
19.	Сначала постройте таблицу сопряжённости, в которой будут указаны доли высказавшихся за ('for') и против ('against') кандидата в разрезе города ('city') и села ('country'). Воспользуйтесь при этом функцией DataFrame() из модуля pandas. Выведите ее на экран.
20. На основе таблицы сопряженности проверьте с помощью критерия хи-квадрат гипотезу о равенстве долей респондентов, высказавшихся за и против кандидата. Воспользуйтесь при этом функцией chi2_contingency() из модуля scipy.stats. Прокомментируйте результат.
"""

table=pd.DataFrame([[28,72],[20,80]],index=['city','country'],columns=['for','against'])
table

stats.chi2_contingency(table,correction=True)
#доля людей, высказавшихся в поддержку кандидата примерно равна в городе и в селе, т.к. p-value - 0.24, это больше порога в 0.05



from google.colab import drive
drive.mount('/content/drive')

"""21.	Имеется следующий набор данных. Сформирована выборка респондентов из 100 человек. Их спросили, проголосуют ли они за одну из австралийских политических партий. Затем им дали послушать рекламу этой политической партии и попросили ответить на тот же вопрос повторно. Ваша задача - оценить убедительность рекламы политической партии.

22.	Загрузите данные из файла по адресу https://raw.githubusercontent.com/ethanweed/pythonbook/main/Data/agpp.csv с помощью функции read_csv() из модуля pandas. Посмотрите на первые 5 наблюдений с помощью функции head().
"""

df = pd.read_csv('https://raw.githubusercontent.com/ethanweed/pythonbook/main/Data/agpp.csv')
df.head(5)

"""23.	Запишите в переменные observed и stats результаты применения теста Мак-Нимара. Воспользуйтесь при этом функцией chi2_mcnemar(df, 'response_before', 'response_after') из модуля pingouin.
24.	Выведите на экран содержимое переменной observed. Прокомментируйте результат.
"""

pg.chi2_mcnemar(df, 'response_before', 'response_after')
observed, stats = pg.chi2_mcnemar(df, 'response_before', 'response_after')

print(observed)

"""25.	Выведите на экран содержимое переменной stats. Прокомментируйте результат."""

stats
#Отвергаем нулеву гипотезу о том, что реклама не влияет, число сторонников уменьшилось, т.е. реклама не убедительна, и даже снижает популярность партии

"""26.	Предположим, что показатель интеллекта IQ некоторой выборки имеет нормальное распределение со средним 100 и стандартным отклонением 15. Требуется проверить, влияет ли новая таблетка на показатель IQ. С этой целью было опрошено 20 респондентов, показатели которых имеют следующий вид: data = [88, 92, 94, 94, 96, 97, 97, 97, 99, 99, 105, 109, 109, 109, 110, 112, 112, 113, 114, 115].
27.	Примените одновыборочный z тест. Воспользуйтесь при этом функцией ztest(data, value=100) из модуля statsmodels.stats.weightstats. Прокомментируйте результат.

"""

from statsmodels.stats.weightstats import ztest

data = [88, 92, 94, 94, 96, 97, 97, 97, 99, 99, 105, 109, 109, 109, 110, 112, 112, 113, 114, 115]
ztest(data, value=100)
#p-value больше 0.05, принимаем нулевую гипотезу, новая таблетка не влияет сильно на уровень IQ

"""28.	Предположим, что показатель интеллекта IQ жителей двух городов имеет нормальное распределение. Требуется проверить, отличаются ли жители городов по уровню интеллекта. С этой целью было опрошено по 20 респондентов из каждого города, их показатели имеют следующий вид:
cityA = [82, 84, 85, 89, 91, 91, 92, 94, 99, 99, 105, 109, 109, 109, 110, 112, 112, 113, 114, 114].
cityB = [90, 91, 91, 91, 95, 95, 99, 99, 108, 109, 109, 114, 115, 116, 117, 117, 128, 129, 130, 133].
29.	Примените двухвыборочный z тест. Воспользуйтесь при этом функцией ztest(cityA, cityB, value=0) из модуля statsmodels.stats.weightstats. Прокомментируйте результат.
"""

cityA = [82, 84, 85, 89, 91, 91, 92, 94, 99, 99, 105, 109, 109, 109, 110, 112, 112, 113, 114, 114]
 cityB = [90, 91, 91, 91, 95, 95, 99, 99, 108, 109, 109, 114, 115, 116, 117, 117, 128, 129, 130, 133]

ztest(cityA, cityB, value=0) 
#p - value < 0.05, отвергаем нулевую гипотезу, уровень IQ существенно Отличается в двух городах

"""30. Загрузите данные из файла ADHD.txt с помощью функции read_csv() из модуля pandas. Дайте названия столбцам, обратившись к атрибуту columns: 'Placebo', 'Methylphenidate'. Здесь 'Placebo' – сведения о пациентах, принимающих плацебо, 'Methylphenidate' – о принимающих лекарство.  Посмотрите на первые 5 наблюдений с помощью функции head()."""

ds = pd.read_csv('/content/drive/MyDrive/data ML/ADHD.txt', sep='\s+')
ds.columns = ['Placebo', 'Methylphenidate']
ds.head(5)

"""31.	Примените одновыборочный критерий Стьюдента для проверки гипотезы о равенстве 50 способности к подавлению импульсивных поведенческих реакций пациентами, принимающими плацебо. Воспользуйтесь при этом функцией ttest_1samp(data.Placebo, 50.0) из модуля scipy.stats.  Прокомментируйте результат."""

from scipy import stats

stats.ttest_1samp(ds.Placebo, 50.0)

"""32.	Загрузите данные из файла agedeath.dat.txt с помощью функции read_csv() из модуля pandas. Через атрибут names функции read_csv() укажите названия столбцов - 'group', 'age', 'index'. Посмотрите на первые 5 наблюдений с помощью функции head().

33.	Данные содержат информацию о продолжительности жизни следующих классов: суверенитет ('sovr'), аристократия ('aris') и дворянство ('gent'). Сохраните в отдельные переменные выборки, которые собираетесь сравнивать, а именно в переменную x – возраст смерти класса 'sovr', а в переменную y – возраст смерти класса 'aris'.

"""

agedeath = pd.read_csv('/content/drive/MyDrive/data ML/agedeath.dat.txt', sep='\s+',header=None,names=['group', 'age', 'index'])
agedeath.head(5)

"""34.	Данные содержат информацию о продолжительности жизни следующих классов: суверенитет ('sovr'), аристократия ('aris') и дворянство ('gent'). Сохраните в отдельные переменные выборки, которые собираетесь сравнивать, а именно в переменную x – возраст смерти класса 'sovr', а в переменную y – возраст смерти класса 'aris'.
	Нанесите на одну диаграмму 2 гистограммы для сравниваемых классов. Воспользуйтесь при этом функцией hist() и функцией legend() из модуля matplotlib.pyplot. Сделайте вывод о нормальности распределений данных двух выборок.

35.	Проверьте гипотезу о равенстве дисперсий на основе критерия Флигнера-Килина. Воспользуйтесь при этом функцией fligner() из модуля scipy.stats. Прокомментируйте результат.
"""

df = pd.read_csv('/content/drive/MyDrive/data ML/agedeath.dat.txt', sep='\s+')
df.columns = ['group', 'age', 'index']
df.head(5)

x = df[df['group']=='sovr']['age']
y = df[df['group']=='aris']['age']
x.name,y.name='sovr','aris'

plt.hist(x)
#распределение отличается от нормального

plt.hist(y)
#распределение отличается от нормального

plt.hist(x, y, color = 'red')
#распределение отличается от нормального

"""35.	Проверьте гипотезу о равенстве дисперсий на основе критерия Флигнера-Килина. Воспользуйтесь при этом функцией fligner() из модуля scipy.stats. Прокомментируйте результат."""

stats.fligner(x,y)
# pvalue=0.00011649324915307631, что ниже 0.05, значит мы отклоняем нулевую гипотезу о равенстве дисперсий

"""36.	Проверьте гипотезу о равенстве средних значений двух независимых классов на основе критерия Стьюдента для независимых выборок. Воспользуйтесь при этом функцией ttest_ind() из модуля scipy.stats. В параметре equal_var этой функции укажите, равны дисперсии (True) или нет (False), опираясь на результаты проверки из п. 15. Прокомментируйте результат."""

stats.ttest_ind(x,y,equal_var = False)
#p-value больше 0.05, нулевая гипотеза о о равенстве средних значений двух независимых классов подтверждается, однако условия для проверки не выполняются.  В случае применения двухвыборочного критерия для независимых выборок также необходимо соблюдение условия равенства дисперсий, у нас дисперсии не равны.

"""37.	Загрузите данные из файла interference.csv с помощью функции read_csv() из модуля pandas. Посмотрите на первые 5 наблюдений с помощью функции head()."""

it = pd.read_csv('/content/drive/MyDrive/data ML/interference.csv')
it.head(5)

"""38.	Данные содержат информацию о скорости чтения названий цветов в зависимости от того, шрифт какого цвета использовался. В столбце 'DiffCol' указана скорость чтения цветного шрифта, а в столбце 'Black' - черно-белого. Сохраните в отдельные переменные выборки, которые собираетесь сравнивать, а именно в переменную x – скорость чтения названий цветов с цветным шрифтом, а в переменную y – скорость чтения названий цветов с черно-белым шрифтом."""

x = it['DiffCol']
y = it['Black']

"""39.	 Посмотрите на гистограммы переменных x и y. Сделайте вывод о нормальности их распределений и о возможности применения критерия Стьюдента для сравнения средних."""

plt.hist(x)
#распределение отличается от нормального

plt.hist(y)
#распределение отличается от нормального

stats.fligner(x,y)
#дисперсии не равны, p-value < 0.05, значит, критерий Стьюдента для сравнения средних неприменим

"""40.	Проверьте гипотезу о равенстве средних значений двух зависимых выборок на основе критерия Стьюдента для зависимых выборок. Воспользуйтесь при этом функцией ttest_rel() из модуля scipy.stats. Прокомментируйте результат."""

stats.ttest_rel(x,y)
#средние значения не равны, p-value < 0.05

"""41.	Загрузите данные из файла Albuquerque Home Prices_data.txt с помощью функции read_csv() из модуля pandas. Посмотрите на первые 5 наблюдений с помощью функции head().
42.	Замените значение -9999, которое здесь употребляется в качестве пустого значения, на корректное пустое значение nan из модуля numpy. Воспользуйтесь при этом функцией replace(). Выведите на экран первые 5 наблюдений преобразованных данных.
"""

df=pd.read_csv('/content/drive/MyDrive/data ML/Albuquerque Home Prices_data.txt', sep='\t') 
df=df.replace(-9999,np.nan)
df.head()

"""43.	Сохраните в отдельные переменные выборки, которые собираетесь сравнивать, а именно в переменную x – цену домов, расположенных на углу улицы (COR = 1), и в переменную y – цену домов, расположенных не на углу улицы (COR = 0)."""

x=df[df['COR']==1]['PRICE']
y=df[df['COR']==0]['PRICE']

"""44.	Нанесите на одну диаграмму 2 гистограммы для сравниваемых типов домов. Воспользуйтесь при этом функцией hist() и функцией legend() из модуля matplotlib.pyplot. Сделайте вывод о нормальности распределений данных двух выборок."""

plt.hist(x, label='цена домов на углу', alpha=0.8, edgecolor='black')
plt.hist(y, label='цена домов не на углу', alpha=0.7, edgecolor='yellow')
plt.show()
#распределения отличаются от нормальных

"""45.	Сравните медианы двух независимых выборок на основе критерия Манна-Уитни. Воспользуйтесь при этом функцией mannwhitneyu() из модуля scipy.stats. Прокомментируйте результат."""

stats.mannwhitneyu(x,y)
#p-value > 0.05, нулевая гипотеза подтверждается: нет статистически разницы между медианами двух независимых выборок. Данный тест использовался, так как распределение не является нормальным

"""46.	Предположим, что перед нами стоит задача сравнить оценки привлекательности продукта до и после просмотра рекламы. Мы знаем, что распределения оценок отличаются от нормального. Поэтому требуется сравнить медианы оценок в двух связанных выборках. 
47.	Выборки будут искусственные. Чтобы результат был воспроизводимым, с помощью функции seed() из модуля numpy.random зададим счетчик случайных чисел. Пусть он принимает значение 1.

"""

import numpy as np
from numpy.random import rand

np.random.seed(1)

"""48.	Сгенерируем 2 выборки оценок продукта (data1, data2), по 100 наблюдений в каждой, путем добавления к медиане каждой выборки случайного числа из равномерного распределения в интервале от 0 до 10. Пусть медиана 1-ой выборки равна 50, а 2-ой – 51. Заданное количество случайных чисел (100) из равномерного распределения в интервале от 0 до 1 можно сгенерировать с помощью функции rand(100) из модуля numpy.random. Преобразуйте найденное число так, чтобы перейти к нужному интервалу чисел (от 0 до 10). Выведите на экран по 5 наблюдений из каждой выборки."""

data1=50+rand(100)*10
data2=51+rand(100)*10

data1[:5]

data2[:5]

"""49.	Сравните медианы двух связанных выборок на основе критерия T-Вилкоксона. Воспользуйтесь при этом функцией wilcoxon(data1, data2) из модуля scipy.stats. Прокомментируйте результат."""

stats.wilcoxon(data1, data2)
# p - value < 0.05, нулевая гипотеза о равенстве выборок и одинаковости распределения не подтвержается

"""50.	Предположим, что перед нами стоит задача сравнить цены продукта в трех регионах. Мы знаем, что распределения цен не существенно отличаются от нормального, дисперсии примерно одинаковые. Поэтому требуется сравнить средние величины в трех независимых выборках, что возможно с помощью дисперсионного анализа. 
51.	Выборки будут искусственные. Чтобы результат был воспроизводимым, с помощью функции seed() из модуля numpy.random зададим счетчик случайных чисел. Пусть он принимает значение 1.

"""

np.random.seed(1)

from numpy.random import randn
from numpy.random import seed

"""52.	Сгенерируем 3 выборки цен продукта (data1, data2, data3), по 100 наблюдений в каждой, путем добавления к средней каждой выборки случайного числа из стандартного нормального распределения, увеличенного в 5 раз. Пусть средняя 1-ой выборки равна 50, 2-ой – 50, 3-й - 52. Заданное количество случайных чисел (100) из стандартного нормального распределения можно сгенерировать с помощью функции randn(100) из модуля numpy.random. Умножьте найденное число на 5. Выведите на экран по 5 наблюдений из каждой выборки."""

data1=50+5*randn(100) 
data2=50+5*randn(100) 
data3=52+5*randn(100)

data1[:5]

data2[:5]

data3[:5]

"""53.	Сравните средние трех независимых выборок с помощью дисперсионного анализа. Воспользуйтесь при этом функцией f_oneway(data1, data2, data3) из модуля scipy.stats. Прокомментируйте результат.

"""

stats.f_oneway(data1, data2, data3) 
# p-value < 0.05, нулевая гипотеза не подтвержается, средние не равны

"""54.	Предположим, что перед нами стоит задача сравнить цены продукта в трех регионах. Мы знаем, что распределения цен отличаются от нормального, а также, что более существенно, дисперсии разные. Поэтому требуется сравнить медианы в трех независимых выборках, что возможно с помощью непараметрического аналога дисперсионного анализа – теста H-Краскала-Уолеса. 
55.	Выборки будут искусственные. Чтобы результат был воспроизводимым, с помощью функции seed() из модуля numpy.random зададим счетчик случайных чисел. Пусть он принимает значение 1.
"""

seed(1)

"""56.	Сгенерируем 3 выборки оценок продукта (data1, data2, data3), по 100 наблюдений в каждой, путем добавления к медиане каждой выборки случайного числа из равномерного распределения в интервале от 0 до 10. Пусть медиана 1-ой выборки равна 50, 2-ой – 51, 3-й - 52. Заданное количество случайных чисел (100) из равномерного распределения в интервале от 0 до 1 можно сгенерировать с помощью функции rand(100) из модуля numpy.random. Преобразуйте найденное число так, чтобы перейти к нужному интервалу чисел (от 0 до 10). Выведите на экран по 5 наблюдений из каждой выборки."""

data1=50+10*rand(100) 
data2=50+10*rand(100) 
data3=52+10*rand(100)

data1[:5]

data2[:5]

data3[:5]

"""57. Сравните медианы трех независимых выборок на основе критерия H-Краскала-Уолеса. Воспользуйтесь при этом функцией kruskal(data1, data2, data3) из модуля scipy.stats. Прокомментируйте результат."""

stats.kruskal(data1, data2, data3)
#нулевая гипотеза о равенстве медиан нескольких выборок не подтвержается, т.к. p-value < 0.05

"""58.	Предположим, что перед нами стоит задача сравнить цены продукта в регионе в разные периоды времени, пусть 3 месяца. Мы знаем, что распределения цен отличаются от нормального, а также, что более существенно, дисперсии разные. Поэтому требуется сравнить медианы в трех зависимых выборках, что возможно с помощью непараметрического аналога дисперсионного анализа с повторными измерениями – теста хи-квадрат Фридмана. 
59.	Предположим, что созданные нами в предыдущем случае выборки data1, data2, data3 (п. 37) содержат цены продукта в регионе в разные периоды времени, пусть за январь, февраль и март.
60. Сравните медианы трех зависимых выборок на основе критерия хи-квадрат Фридмана. Воспользуйтесь при этом функцией friedmanchisquare(data1, data2, data3) из модуля scipy.stats. Прокомментируйте результат.
"""

stats.friedmanchisquare(data1, data2, data3)
# p -value < 0.05, отвергаем нулевую гипотезу о равенстве медиан

"""61.	Допустим, вы интересуетесь влиянием разговоров по мобильному телефону на время реакции водителя. Вы создали выборку из людей, случайно отнесенных к той или иной экспериментальной группе. В первой группе участники исследования при работе на тренажере реагировали на ряд сложных для водителя ситуаций, разговаривая по мобильному телефону. Во второй группе люди выполняли то же задание, но уже без мобильного телефона. Для каждого человека регистрировали общее время реакции. Вы используете двухсторонний тест Стьюдента для независимых выборок, чтобы сравнить среднее время реакции для водителей с мобильным телефоном и для водителей без отвлекающих факторов.
62.	Предположим, по предыдущим исследованиям вам известно, что стандартное отклонение времени реакции составляет 1,25 секунды. Также предположим, что различие во времени реакции на 1 секунду считается существенным. Таким образом, вам хотелось бы провести исследование, в котором можно было обнаружить эффект величиной d=((μ_1-μ_2 ))/σ=1/1.25=0.8  или больше, где μ_1 – среднее значение для 1-й группы, μ_2 – среднее значение для 2-й группы, σ – стандартное отклонение общей ошибки. В дополнение к этому вы хотите быть уверенными на 90% в том, что действительно обнаружите различия, если они существуют, и на 95% - в том, что вы не назовете значимым то различие, которое на самом деле является результатом случайных флуктуаций. Сколько человек вам нужно обследовать?
63.	Создайте класс анализа мощности для критерия Стьюдента с помощью функции TTestIndPower(). Результат запишите в переменную analysis.
64.	Проведите анализ мощности для поиска объема выборки, воспользовавшись функцией solve_power(effect, power=power, nobs1=None, ratio=1.0, alpha=alpha, alternative='two-sided'). Прокомментируйте результат.

"""

effect = 0.8
power = 0.9
alpha = 0.05

import statsmodels.stats.power

analysis = statsmodels.stats.power.TTestIndPower()

analysis.solve_power(effect, power=power, nobs1=None, ratio=1.0, alpha=alpha, alternative='two-sided')

"""65.	Представим, что, сравнивая две группы, вы хотите, чтобы можно было обнаружить различие между выборочными средними в 0,5 стандартного отклонения. Вы хотите снизить шансы обнаружения различий по ошибке до 1 из 100. Кроме того, вы можете исследовать только по 20 человек в группе. С какой вероятностью вы сможете выявить различия между выборочными средними при таких условиях?
66.	Проведите анализ мощности для поиска мощности, воспользовавшись функцией solve_power(effect, power=None, nobs1=n, ratio=1.0, alpha=alpha). Прокомментируйте результат.

"""

effect = 2
n = 40
alpha = 0.05

analysis.solve_power(effect, power=None, nobs1=n, ratio=1.0, alpha=alpha)

"""67.	Рассмотрите эффекты, равные 0.2, 0.5, 0.8. Представьте их в виде массива numpy и запишите в переменную effect_sizes.
68.	Рассмотрите объемы выборок от 5 до 100 наблюдений. Представьте их в виде массива numpy и запишите в переменную sample_sizes.
69.	Изобразите кривые мощности, показывающие зависимость между количеством наблюдений и мощностью, при различных величинах эффекта, воспользовавшись функцией plot_power(dep_var='nobs', nobs=sample_sizes, effect_size=effect_sizes) и функцией show() из модуля matplotlib.pyplot. Представьте и прокомментируйте результат.

"""

effect_sizes = np.array[0.2, 0.5, 0.8]

"""70.	Для однофакторного дисперсионного анализа, включающего 5 групп, нужно найти размер групп, при котором мощность составляет 0.8, размер эффекта – 0.25 и уровень значимости – 0.05. Для однофакторного дисперсионного анализа величина эффекта отражена в параметре f, который рассчитывается по формуле:
f=√((∑_(i=1)^k▒〖p_i (μ_i-μ)^2 〗)/σ^2 ),
p_i=n_i/N,
где k – число групп,
n_i – размер выборки в группе i,
N – общее число наблюдений,
μ_i – среднее значение для группы i,
μ – общее среднее,
σ^2 – дисперсия ошибок внутри групп.
71.	Создайте класс анализа мощности для сбалансированного однофакторного дисперсионного анализа с помощью функции FTestAnovaPower(). Результат запишите в переменную analysis.
72.	Проведите анализ мощности для поиска объема выборки, воспользовавшись функцией solve_power(effect_size=effect, nobs=None, alpha=alpha, k_groups=k, power=power). Прокомментируйте результат.

"""

